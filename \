.section	.rodata
	# error messages.
	.err_unknw_fmt_msg:	.string "printf_: unknown fmt.\n"
	.err_unknw_fmt_len:	.long	22


	.buffer_cap:	.quad	2048
	.test:		.string "hola como estas"

.section	.bss
	.buffer:	.zero	2048

.section	.text
.globl		printf_
.globl		_start


.macro	A, a
	movq	\a, %rdi
	movq	$60, %rax
	syscall
.endm

_start:
	movl	$1, %edi
	leaq	.test(%rip), %rsi
	pushq	$72
	pushq	$4
	call	printf_
	A	$-1


# arguments:	fd (edi) ; fmt (rsi) ; arguments (pushed into the stack)
# return:	number of bytes written.
# regs:		rax, rdi, rsi
printf_:
	pushq	%rbp
	movq	%rsp, %rbp
	subq	$36, %rsp
	# stack distribution.
	# -8(%rbp):	index of the current argument.
	# -12(%rbp):	write to (fd).
	# -20(%rbp):	format.
	# -28(%rbp):	pointer to the buffer.
	# -36(%rbp):	number of bytes written so far (into the buffer).
	movq	$0, -8(%rbp)
	movq	$0, -36(%rbp)
	movl	%edi, -12(%rbp)
	movq	%rsi, -20(%rbp)
	leaq	.buffer(%rip), %rax
	movq	%rax, -28(%rbp)
.printf_loop:
	movq	-20(%rbp), %rax
	movzbl	(%rax), %edi
	testl	%edi, %edi
	jz	.printf_goodbye

	cmpb	$'%', %dil
	je	.printf_fmt_found



	# go for the next character in the fmt.
	incq	-20(%rbp)
	jmp	.printf_loop

.printf_fmt_found:
	# get the next character to `%'
	movzbl	1(%rax), %eax
	cmpb	$'d', %al
	je	.printf_fmt_number
	cmpb	$'s', %al
	je	.printf_fmt_string
	cmpb	$'c', %al
	je	.printf_fmt_character
	jmp	.printf_err_unknown_fmt

.printf_fmt_number:
.printf_fmt_string:
.printf_fmt_character:
	A	$-2

.printf_goodbye:
	movq	-36(%rbp), %rax
	leave
	ret

.printf_err_unknown_fmt:

